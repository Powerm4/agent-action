'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs/promises');
var path = require('path');
var fetch = require('node-fetch');
var en = require('./locales/en.js');
var debug = require('./utils/debug.js');
require('./utils/filter-artifacts.js');
require('child_process');
require('env-ci');
var maskObjectProperty = require('./utils/mask-object-property.js');
var logger = require('./utils/logger.js');

async function ingest(data, params, config = {}, logger$1 = logger.logger) {
    const { key, endpoint, branch, build, buildUrl, commit, pr, slug, service, commitMessage, agentVersion, } = params;
    const payload = {
        key,
        project: slug,
        service,
        agentVersion,
        job: {
            commit,
            branch,
            prNumber: pr,
            buildNumber: build,
            buildUrl,
            commitMessage,
        },
        rawData: data,
    };
    const formattedPayload = maskObjectProperty.maskObjectProperties(payload, ['key']);
    debug.debug('Payload size', Buffer.byteLength(JSON.stringify(payload)));
    const { payloadFilepath } = config;
    /**
     * Save payload on disk for debugging
     */
    if (payloadFilepath) {
        logger$1.info('Save payload to', payloadFilepath);
        try {
            const payloadBaseDirectory = path.dirname(payloadFilepath);
            await fs.mkdir(payloadBaseDirectory, { recursive: true });
            await fs.writeFile(payloadFilepath, JSON.stringify(formattedPayload, null, 2));
        }
        catch (err) {
            // On error, catch and log
            logger$1.warn(`Error saving payload to "${payloadFilepath}"`, err instanceof Error ? err.message : undefined);
        }
    }
    logger$1.info('Send bundle stats to RelativeCI', `branch=${branch}`, `commit=${commit}`);
    let responseData = null;
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
            },
            body: JSON.stringify(payload),
        });
        responseData = await response.json();
        debug.debug('Response', responseData);
    }
    catch (error) {
        throw new Error(en.INGEST_ERROR, { cause: error });
    }
    if (!responseData) {
        throw new Error(en.INGEST_INVALID_DATA);
    }
    if (responseData.code) {
        throw new Error(responseData.message, { cause: responseData });
    }
    if (!responseData.res) {
        throw new Error(en.INGEST_INVALID_DATA, { cause: responseData });
    }
    return responseData;
}

exports.default = ingest;
//# sourceMappingURL=ingest.js.map
