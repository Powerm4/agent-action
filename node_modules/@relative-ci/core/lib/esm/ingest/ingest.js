import fs from 'node:fs/promises';
import path from 'node:path';
import { gzip as gzip$1 } from 'node:zlib';
import { promisify } from 'node:util';
import { INGEST_ERROR, INGEST_INVALID_DATA } from '../locales/en.js';
import { debug } from '../utils/debug.js';
import { formatFileSize } from '../utils/file-size.js';
import { logger } from '../utils/logger.js';
import { maskObjectProperties } from '../utils/mask-object-property.js';

const gzip = promisify(gzip$1);
async function ingest(data, params, config = {}, logger$1 = logger) {
    const { key, endpoint, branch, baseBranch, build, buildUrl, commit, pr, slug, service, commitMessage, agentVersion, agentType, } = params;
    const payload = {
        key,
        project: slug,
        service,
        agentVersion,
        agentType,
        job: {
            commit,
            branch,
            baseBranch,
            prNumber: pr,
            buildNumber: build,
            buildUrl,
            commitMessage,
        },
        rawData: data,
    };
    const { compress, payloadFilepath } = config;
    let requestBody = JSON.stringify(payload);
    let payloadSize = 0;
    if (compress) {
        requestBody = await gzip(requestBody);
        payloadSize = requestBody.byteLength;
    }
    else {
        payloadSize = Buffer.byteLength(requestBody);
    }
    debug(`Payload size ${compress ? '(compressed)' : ''}`, formatFileSize(payloadSize));
    /**
     * Save payload on disk for debugging
     */
    if (payloadFilepath) {
        logger$1.info('Save payload to', payloadFilepath);
        try {
            const formattedPayload = maskObjectProperties(payload, ['key']);
            const payloadBaseDirectory = path.dirname(payloadFilepath);
            await fs.mkdir(payloadBaseDirectory, { recursive: true });
            await fs.writeFile(payloadFilepath, JSON.stringify(formattedPayload, null, 2));
        }
        catch (err) {
            // On error, catch and log
            logger$1.warn(`Error saving payload to "${payloadFilepath}"`, err instanceof Error ? err.message : undefined);
        }
    }
    logger$1.log('Send bundle stats to RelativeCI', `branch=${branch}`, `commit=${commit}`);
    let responseData = null;
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
                ...(compress && {
                    'Content-Encoding': 'gzip',
                }),
            },
            body: requestBody,
        });
        responseData = await response.json();
        debug('Response', responseData);
    }
    catch (error) {
        throw new Error(INGEST_ERROR, { cause: error });
    }
    if (!responseData) {
        throw new Error(INGEST_INVALID_DATA);
    }
    if (responseData.code) {
        throw new Error(responseData.message, { cause: responseData });
    }
    if (!responseData.res) {
        throw new Error(INGEST_INVALID_DATA, { cause: responseData });
    }
    return responseData;
}

export { ingest as default };
//# sourceMappingURL=ingest.js.map
